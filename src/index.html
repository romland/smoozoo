<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Smoozoo with Hotspots</title>
    <style>
        html {
            background-color: #0e0422;
        }

        body {
            overflow: hidden;
            margin: 0;
        }

        canvas {
            display: block;
        }

        .display {
            z-index: 2;
            position: fixed;
            background-color: rgba(0, 0, 0, 0.65);
            color: #ffffff;
            padding: 5px 15px;
            border-radius: 5px;
            border: 1px solid #444;
            font-family: Consolas, "Andale Mono", "Lucida Console", monospace;
            font-size: 14px;
            pointer-events: none;
            user-select: none;
        }

        #status-display {
            bottom: 5px;
            right: 10px;
        }

        #status-display p {
            margin: 4px 0;
            display: inline-block;
            white-space: nowrap;
        }

        .pan-slider-container {
            pointer-events: auto !important;
        }

        p.narrow {
            width: 70px;
        }

        p.wide {
            width: 120px !important;
        }

        #status-display span {
            color: #82eefd;
        }

        #control-display {
            position: fixed;
            bottom: 40px;
            width: 15%;
            left: 50%;
            transform: translateX(-50%);
        }

        #pan-slider {
            background-color: rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 1);
            border-radius: 8px;
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            pointer-events: auto;
        }

        #minimap-container {
            position: fixed;
            top: 20px;
            right: 20px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            background-color: rgba(14, 4, 34, 0.75);
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            z-index: 100;
            display: none;
            cursor: pointer;
            pointer-events: auto;
        }

        #minimap-image {
            width: 100%;
            height: 100%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.7;
        }

        #minimap-viewport {
            position: absolute;
            border: 2px solid #ff5555;
            background-color: rgba(255, 85, 85, 0.25);
            pointer-events: none;
        }

		/* --- Hotspot Plugin Styles --- */
		#hotspot-layer {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			z-index: 10;
		}

		.hotspot-marker, .hotspot-cluster-marker {
			position: absolute;
			border-radius: 50%;
			transform: translate(-50%, -50%);
			transition: background-color 0.3s, transform 0.3s, border-color 0.3s;
			pointer-events: auto;
			cursor: pointer;
			box-shadow: 0 2px 10px rgba(0,0,0,0.4);
		}

		.hotspot-marker {
			background-color: rgba(255, 235, 59, 0.3);
			border: 2px solid rgba(255, 235, 59, 0.9);
		}

		.hotspot-marker:hover {
			background-color: rgba(255, 235, 59, 0.8);
			transform: translate(-50%, -50%) scale(1.2);
		}

		.hotspot-cluster-marker {
			background-color: rgba(33, 150, 243, 0.6);
			border: 2px solid rgba(33, 150, 243, 1);
			color: white;
			font-size: 14px;
			font-weight: bold;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			
			/* Use text-align for horizontal centering. */
			text-align: center;
		}

        .hotspot-cluster-marker > small {
            font-weight: 100;
        }

		.hotspot-cluster-marker:hover {
			background-color: rgba(33, 150, 243, 1);
			transform: translate(-50%, -50%) scale(1.1);
		}


		.hotspot-popup-shared {
			position: fixed; /* Remains fixed to the viewport */
			top: 0; /* Set top/left to 0 as a baseline */
			left: 0;
			will-change: transform; /* Hint to the browser to optimize for transform changes */
			display: none;
			width: 300px;
			max-height: 400px;
			overflow-y: auto;
			background-color: rgba(28, 19, 58, 0.9);
			color: #f0f0f0;
			border: 1px solid #82eefd;
			border-radius: 8px;
			padding: 15px;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			font-size: 14px;
			backdrop-filter: blur(10px);
			box-shadow: 0 5px 25px rgba(0,0,0,0.6);
			user-select: none;
			z-index: 20;
			pointer-events: auto;
			transition: border-color 0.3s, box-shadow 0.3s;
		}

		.hotspot-popup-shared.is-sticky {
			border-color: #ff6bf8;
			box-shadow: 0 0 30px rgba(255, 107, 248, 0.7);
		}

		.hotspot-popup-shared h3 {
			margin: 0 0 8px 0;
			color: #82eefd;
			font-size: 16px;
		}

		.hotspot-popup-shared p {
			margin: 0 0 10px 0;
			line-height: 1.5;
		}

		.hotspot-popup-shared img {
			max-width: 100%;
			border-radius: 4px;
			margin-top: 5px;
		}

		.hotspot-footer {
			font-size: 12px;
		}

		.hotspot-separator {
			border: none;
			height: 1px;
			background-color: rgba(130, 238, 253, 0.3);
			margin: 15px 0;
		}

    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>

    <div id="hotspot-layer"></div>

    <div id="minimap-container">
        <div id="minimap-image"></div>
        <div id="minimap-viewport"></div>
    </div>

    <div id="control-display" class="">
        <p class="pan-slider-container">
            <input type="range" id="pan-slider" min="0" max="100" value="0">
        </p>
    </div>

    <div id="status-display" class="display">
        <p class="narrow"><strong>üîç </strong><span id="zoom-level">1.00</span>x</p>
        <p class="wide"><strong>‚åñ </strong><span id="mouse-coords">0, 0</span></p>
        <p class="wide"><strong>üóé </strong><span id="image-size-pixels">0x0</span></p>
        <p class="narrow"><strong></strong><span id="image-size-bytes">0 B</span></p>
        <p><strong></strong><span id="image-file-name"></span></p>
    </div>

<script>
class HotspotPlugin {
    constructor(viewer, options) {
        this.viewer = viewer;
        this.hotspots = options.hotspots || [];
        this.container = document.getElementById('hotspot-layer');
        this.activeHotspots = [];
        this.stickyHotspots = [];
        this.mouseScreenPos = { x: 0, y: 0 };

        this.clusterRadius = 80;
        this.zoomThreshold = 0.5;
        this.markerPool = [];
        this.activeMarkers = [];
        this.popupAnchor = null;
        
        this.lastPopupPosition = { x: null, y: null };
        this.popupMoveThreshold = 1.5; // Only move popup if anchor moves more than this many pixels.

        this.handleMarkerClick = this.handleMarkerClick.bind(this);
        this.handleOutsideClick = this.handleOutsideClick.bind(this);
        this.init();
    }
	
    init() {
        this.container.innerHTML = '';
        this.popup = document.createElement('div');
        this.popup.className = 'hotspot-popup-shared';
        this.container.appendChild(this.popup);
        document.addEventListener('click', this.handleOutsideClick);
    }

    // --- MODIFIED: Click handler now robustly sets the anchor object ---
    handleMarkerClick(e, data, markerElement) {
        e.stopPropagation();
        
        // The anchor is always the specific marker that was clicked.
        const anchor = { marker: markerElement, screenPos: data.screenPos };

        if (data.isCluster) {
            this.stickyHotspots = [...data.hotspots];
        } else {
            // If overlapping individual markers are hovered, make them all sticky.
            if (this.activeHotspots.length > 0) {
                this.stickyHotspots = [...this.activeHotspots];
            }
        }
        
        this.popupAnchor = anchor;
        this.activeHotspots = []; // Clear hover state
        this.viewer.requestRender();
    }

    handleOutsideClick(e) {
        if (this.stickyHotspots.length > 0 && !this.popup.contains(e.target)) {
            this.stickyHotspots = [];
            this.popupAnchor = null;
            this.viewer.requestRender();
        }
    }

    worldToScreen(worldX, worldY) {
        const { scale, originX, originY } = this.viewer.getTransform();
        return { x: (worldX + originX) * scale, y: (worldY + originY) * scale };
    }

    onMouseMove(e) {
        if (this.stickyHotspots.length > 0) {
            if (this.activeHotspots.length > 0) {
                this.activeHotspots = [];
                this.viewer.requestRender();
            }
            return;
        }
        
        const isHoverPopupVisible = this.activeHotspots.length > 0 && this.popup.style.display === 'block';
        if (isHoverPopupVisible && this.popup.contains(e.target)) {
            return;
        }

        const previousHotspots = [...this.activeHotspots];
        const canvasRect = this.viewer.getCanvas().getBoundingClientRect();
        this.mouseScreenPos = { x: e.clientX, y: e.clientY };

        if (e.clientX >= canvasRect.left && e.clientX <= canvasRect.right &&
            e.clientY >= canvasRect.top && e.clientY <= canvasRect.bottom) {
            this.checkForHover();
        } else {
            this.activeHotspots = [];
            this.popupAnchor = null;
        }

        if (this.activeHotspots.length !== previousHotspots.length ||
            !this.activeHotspots.every((h, i) => h.id === previousHotspots[i]?.id)) {
            this.viewer.requestRender();
        }
    }
    
    // --- MODIFIED: Sets the full anchor object on hover ---
    checkForHover() {
        let foundHotspots = [];
        let hoveredClusterData = null;
    
        for (const markerData of this.activeMarkers) {
            const markerRadius = markerData.marker.offsetWidth / 2;
            const distance = Math.sqrt(
                Math.pow(this.mouseScreenPos.x - markerData.screenPos.x, 2) +
                Math.pow(this.mouseScreenPos.y - markerData.screenPos.y, 2)
            );
    
            if (distance <= markerRadius) {
                if (markerData.isCluster) {
                    hoveredClusterData = markerData;
                    break; 
                } else {
                    foundHotspots.push(markerData.hotspot);
                }
            }
        }
        
        if (hoveredClusterData) {
            this.activeHotspots = hoveredClusterData.hotspots;
            this.popupAnchor = { marker: hoveredClusterData.marker, screenPos: hoveredClusterData.screenPos };
        } else {
            this.activeHotspots = foundHotspots;
            if (foundHotspots.length > 0) {
                const firstActiveId = foundHotspots[0].id;
                const markerData = this.activeMarkers.find(m => !m.isCluster && m.hotspot.id === firstActiveId);
                if (markerData) {
                    this.popupAnchor = { marker: markerData.marker, screenPos: markerData.screenPos };
                } else {
                    this.popupAnchor = null;
                }
            } else {
                this.popupAnchor = null;
            }
        }
    }

    getMarkerFromPool() {
        if (this.markerPool.length > 0) {
            const marker = this.markerPool.pop();
            marker.style.display = 'block';
            return marker;
        }
        const marker = document.createElement('div');
        this.container.appendChild(marker);
        return marker;
    }

    releaseMarkerToPool(marker) {
        marker.style.display = 'none';
        marker.className = '';
        marker.onclick = null;
        this.markerPool.push(marker);
    }

    update() {
        // This update flow remains the same.
        const canvas = this.viewer.getCanvas();
        const transform = this.viewer.getTransform();
        const canvasBounds = { left: 0, top: 0, right: canvas.width, bottom: canvas.height };

        this.activeMarkers.forEach(({ marker }) => this.releaseMarkerToPool(marker));
        this.activeMarkers = [];

        const visibleHotspots = this.hotspots.map(hotspot => ({
            hotspot,
            screenPos: this.worldToScreen(hotspot.x, hotspot.y)
        })).filter(({ screenPos }) =>
            screenPos.x >= canvasBounds.left && screenPos.x <= canvasBounds.right &&
            screenPos.y >= canvasBounds.top && screenPos.y <= canvasBounds.bottom
        );

        if (transform.scale < this.zoomThreshold) {
            const clusters = [];
            let visited = new Set();
            for (const { hotspot, screenPos } of visibleHotspots) {
                if (visited.has(hotspot.id)) continue;
                const neighbors = visibleHotspots.filter(other => {
                    const dist = Math.sqrt(Math.pow(screenPos.x - other.screenPos.x, 2) + Math.pow(screenPos.y - other.screenPos.y, 2));
                    return dist < this.clusterRadius;
                });

                if (neighbors.length > 1) {
                    let totalX = 0, totalY = 0;
                    neighbors.forEach(n => {
                        totalX += n.screenPos.x;
                        totalY += n.screenPos.y;
                        visited.add(n.hotspot.id);
                    });
                    const center = { x: totalX / neighbors.length, y: totalY / neighbors.length };
                    
                    clusters.push({
                        isCluster: true,
                        count: neighbors.length,
                        hotspots: neighbors.map(n => n.hotspot),
                        center: center,
                        screenPos: center
                    });
                } else {
                    clusters.push({ ...hotspot, screenPos });
                    visited.add(hotspot.id);
                }
            }
            this.renderMarkers(clusters);
        } else {
            this.renderMarkers(visibleHotspots.map(h => ({ ...h.hotspot, screenPos: h.screenPos })));
        }
        this.updatePopup();
    }

	renderMarkers(items) {
        items.forEach(item => {
            const marker = this.getMarkerFromPool();
            marker.style.left = `${item.screenPos.x}px`;
            marker.style.top = `${item.screenPos.y}px`;
            
            let markerData;
            if (item.isCluster) {
                marker.className = 'hotspot-cluster-marker';
                marker.innerHTML = "<br/>" + item.count + "<br/><small>tweets</small>";
                const diameter = 30 + Math.log2(item.count) * 5;
                marker.style.width = `${diameter}px`;
                marker.style.height = `${diameter}px`;
                
                // --- THE FIX ---
                // Set the line-height equal to the height to vertically center the text.
                marker.style.lineHeight = `${diameter/4}px`;

                markerData = { ...item, marker };
            } else {
                // (The rest of the function is unchanged)
                marker.className = 'hotspot-marker';
                marker.innerText = '';
                const diameter = Math.max(5, item.radius * 2 * this.viewer.getTransform().scale);
                marker.style.width = `${diameter}px`;
                marker.style.height = `${diameter}px`;
                markerData = { hotspot: item, marker, screenPos: item.screenPos };
            }
            
            marker.onclick = (e) => this.handleMarkerClick(e, item, marker);
            this.activeMarkers.push(markerData);
        });
    }
	
    updatePopup() {
        const hotspotsToShow = this.stickyHotspots.length > 0 ? this.stickyHotspots : this.activeHotspots;

        if (hotspotsToShow.length > 0 && this.popupAnchor) {
            this.popup.style.display = 'block'; // Ensure popup is visible to measure it
            
            // Build content (unchanged)
            let contentHTML = '';
            hotspotsToShow.forEach((hotspot, index) => {
                if (hotspot.content.title) contentHTML += `<h3>${hotspot.content.title}</h3>`;
                if (hotspot.content.text) contentHTML += `<p>${hotspot.content.text}</p>`;
                if (hotspot.content.image) contentHTML += `<img src="${hotspot.content.image}" alt="${hotspot.content.title || 'Hotspot Image'}">`;
                if (hotspot.content.subtitle) contentHTML += `<p class="hotspot-footer">${hotspot.content.subtitle}</p>`;
                if (index < hotspotsToShow.length - 1) {
                    contentHTML += '<hr class="hotspot-separator">';
                }
            });
            this.popup.innerHTML = contentHTML;
            this.popup.classList.toggle('is-sticky', this.stickyHotspots.length > 0);

            // --- Positioning and Smoothing Logic ---
            const marker = this.popupAnchor.marker;
            const screenPos = this.popupAnchor.screenPos;
            const markerRect = {
                top: screenPos.y - marker.offsetHeight / 2, left: screenPos.x - marker.offsetWidth / 2,
                width: marker.offsetWidth, height: marker.offsetHeight,
                bottom: screenPos.y + marker.offsetHeight / 2, right: screenPos.x + marker.offsetWidth / 2,
            };

            // Measure the popup itself once
            const popupRect = this.popup.getBoundingClientRect();
            const margin = 15;

            // Find best placement
            const placements = {
                above: { top: markerRect.top - popupRect.height - margin, left: markerRect.left + markerRect.width / 2 - popupRect.width / 2 },
                below: { top: markerRect.bottom + margin, left: markerRect.left + markerRect.width / 2 - popupRect.width / 2 },
                right: { top: markerRect.top + markerRect.height / 2 - popupRect.height / 2, left: markerRect.right + margin },
                left: { top: markerRect.top + markerRect.height / 2 - popupRect.height / 2, left: markerRect.left - popupRect.width - margin }
            };

            let bestPlacement = null;
            for (const key of ['above', 'below', 'right', 'left']) {
                const p = placements[key];
                if (p.top > margin && p.left > margin && (p.top + popupRect.height) < window.innerHeight - margin && (p.left + popupRect.width) < window.innerWidth - margin) {
                    bestPlacement = p;
                    break;
                }
            }
            const finalPlacement = bestPlacement || placements.left;

            // ** THE SMOOTHING FIX **
            // Calculate distance from the last rendered position
            const dist = Math.hypot(finalPlacement.left - this.lastPopupPosition.x, finalPlacement.top - this.lastPopupPosition.y);

            // If we have a previous position and the new one is too close, do nothing.
            if (this.lastPopupPosition.x !== null && dist < this.popupMoveThreshold) {
                return;
            }
            
            // Otherwise, update the position with a smooth CSS transform.
            this.popup.style.transform = `translate(${finalPlacement.left}px, ${finalPlacement.top}px)`;
            this.lastPopupPosition = { x: finalPlacement.left, y: finalPlacement.top };

        } else {
            this.popup.style.display = 'none';
            this.lastPopupPosition = { x: null, y: null }; // Reset when hidden
        }
    }


    
    destroy() {
        document.removeEventListener('click', this.handleOutsideClick);
        this.container.innerHTML = '';
    }
}

    window.addEventListener('load', () => {
        // Settings
        const settings = {
            minimapMaxSize: 200,
            minimapMinSize: 8,
            elasticMoveDuration: 200,
            zoomSmoothing: 0.075,
            inertiaFriction: 0.95,
            inertiaStopThreshold: 0.1,
        }

        // DOM Element Selection & Initial Setup
        const canvas = document.getElementById('glcanvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert("WebGL is not supported in your browser.");
            throw new Error("WebGL not supported");
        }

        const zoomLevelSpan = document.getElementById('zoom-level');
        const mouseCoordsSpan = document.getElementById('mouse-coords');
        const imageSizePixelsSpan = document.getElementById('image-size-pixels');
        const imageSizeBytesSpan = document.getElementById('image-size-bytes');
        const imageFilenameSpan = document.getElementById('image-file-name');

        const panSlider = document.getElementById('pan-slider');
        const minimapContainer = document.getElementById('minimap-container');
        const minimapImage = document.getElementById('minimap-image');
        const minimapViewport = document.getElementById('minimap-viewport');

        // State Variables
        let scale = 1.0,
            originX = 0,
            originY = 0;
        let tiles = [],
            panning = false;
        let startX = 0,
            startY = 0;

        // Variables for smooth zooming
        let targetScale = 1.0;
        let targetOriginX = 0;
        let targetOriginY = 0;
        let isZooming = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Variables for inertial panning
        let panVelocityX = 0;
        let panVelocityY = 0;
        let lastPanTime = 0;

        // Image properties
        let orgImgWidth = 0;
        let orgImgHeight = 0;
        let orgImgBytes = 0;
        let rotation = 0;
        let minScale = 0.1;

        // Animation state tracking
        let inertiaAnimationId = null;
        let elasticMoveAnimationId = null;
        let smoothZoomAnimationId = null;

        // Get the maximum texture size the GPU can handle. This is crucial for the tiling logic.
        const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);

        // ------------------------
        // --- Matrix Utilities ---
        // ------------------------
        const mat3 = {
            /**
             * Multiplies two 3x3 matrices.
             * @param {number[]} a The first matrix.
             * @param {number[]} b The second matrix.
             * @returns {number[]} The result of the multiplication.
             */
            multiply: (a, b) => {
                const a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8];
                const b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
                return [
                    b00 * a00 + b01 * a10 + b02 * a20, b00 * a01 + b01 * a11 + b02 * a21, b00 * a02 + b01 * a12 + b02 * a22,
                    b10 * a00 + b11 * a10 + b12 * a20, b10 * a01 + b11 * a11 + b12 * a21, b10 * a02 + b11 * a12 + b12 * a22,
                    b20 * a00 + b21 * a10 + b22 * a20, b20 * a01 + b21 * a11 + b22 * a21, b20 * a02 + b21 * a12 + b22 * a22
                ];
            },

            /** Creates a translation matrix. */
            translation: (tx, ty) => [1, 0, 0, 0, 1, 0, tx, ty, 1],

            /** Creates a rotation matrix. */
            rotation: (angleInRad) => {
                const c = Math.cos(angleInRad);
                const s = Math.sin(angleInRad);
                return [c, -s, 0, s, c, 0, 0, 0, 1];
            },
        };

        // ---------------------
        // --- WebGL Shaders ---
        // ---------------------
        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texcoord;
            varying vec2 v_texcoord;
            uniform mat3 u_viewProjectionMatrix;
            uniform mat3 u_rotationMatrix;

            void main() {
                vec3 rotated_position = u_rotationMatrix * vec3(a_position, 1.0);
                vec3 final_position = u_viewProjectionMatrix * vec3(rotated_position.xy, 1.0);
                gl_Position = vec4(final_position.xy, 0.0, 1.0);
                v_texcoord = a_texcoord;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            varying vec2 v_texcoord;
            uniform sampler2D u_image;

            void main() {
                gl_FragColor = texture2D(u_image, v_texcoord);
            }
        `;


        // ------------------------------
        // --- WebGL Helper Functions ---
        // ------------------------------
        function createShader(gl, type, source)
        {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Error compiling shader:", gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }


        function createProgram(gl, vertexShader, fragmentShader)
        {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Error linking program:", gl.getProgramInfoLog(program));
                gl.deleteShader(program);
                return null;
            }

            return program;
        }


        /**
         * Sets the vertex positions for a rectangle.
         */
        function setRectangle(gl, x, y, width, height)
        {
            const x1 = x,
                  x2 = x + width,
                  y1 = y,
                  y2 = y + height;

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(
                [ x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2 ]
            ), gl.STATIC_DRAW);
        }


        /**
         * Creates a view-projection matrix to transform from pixel space to clip space.
         */
        function makeMatrix(tx, ty, scale)
        {
            const m0 = scale * 2 / canvas.width,
                  m4 = scale * -2 / canvas.height,
                  m6 = (scale * 2 * tx / canvas.width) - 1,
                  m7 = (scale * -2 * ty / canvas.height) + 1;

            return [ m0, 0, 0, 0, m4, 0, m6, m7, 1 ];
        }


        /**
         * Formats a number of bytes into a human-readable string (KB, MB, GB, etc.).
         */
        function formatBytes(bytes, d = 2)
        {
            if (bytes === 0)
                return '0 B';

            const k = 1024,
                  dm = d < 0 ? 0 : d,
                  s = ['B', 'KB', 'MB', 'GB', 'TB'],
                  i = Math.floor(Math.log(bytes) / Math.log(k));

            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + s[i];
        }


        /**
         * Loads an image, splits it into tiles if necessary, and creates WebGL textures.
         */
        async function loadImageAndCreateTextureInfo(url, callback)
        {
            try {
                const response = await fetch(url);

                if (!response.ok)
                    throw new Error(`HTTP error! status: ${response.status}`);

                const blob = await response.blob();
                orgImgBytes = blob.size;
                const objectURL = URL.createObjectURL(blob);

                const img = new Image();
                img.crossOrigin = "anonymous";
                img.src = objectURL;

                img.onload = function() {
                    orgImgWidth = img.width;
                    orgImgHeight = img.height;
                    generateMinimapThumbnail(img);

                    const numXTiles = Math.ceil(img.width / maxTextureSize);
                    const numYTiles = Math.ceil(img.height / maxTextureSize);

                    for (let y = 0; y < numYTiles; y++) {
                        for (let x = 0; x < numXTiles; x++) {
                            const sx = x * maxTextureSize,
                                  sy = y * maxTextureSize,
                                  sw = Math.min(maxTextureSize, img.width - sx),
                                  sh = Math.min(maxTextureSize, img.height - sy);

                            const tileCanvas = document.createElement('canvas');
                            tileCanvas.width = sw;
                            tileCanvas.height = sh;

                            const tileCtx = tileCanvas.getContext('2d');
                            tileCtx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);

                            const texture = gl.createTexture();
                            gl.bindTexture(gl.TEXTURE_2D, texture);
                            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tileCanvas);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

                            tiles.push({
                                texture,
                                x: sx,
                                y: sy,
                                width: sw,
                                height: sh
                            });
                        }
                    }

                    imageFilenameSpan.textContent = url.split('/').pop();
                    URL.revokeObjectURL(objectURL);
                    callback();
                };
            } catch (error) {
                console.error("Failed to load image:", error);
                alert("Failed to load image.");
            }
        }

        let hotspotPlugin; // Declare at this scope

        /**
         * The main rendering loop. Draws all tiles to the canvas.
         */
        function render()
        {
            if (!tiles.length) {
                return;
            }

            gl.clearColor(0.055, 0.016, 0.133, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(program);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            gl.enableVertexAttribArray(texcoordLocation);
            gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);

            const angleInRad = rotation * Math.PI / 180;
            let rotMtx = mat3.translation(orgImgWidth / 2, orgImgHeight / 2);
            rotMtx = mat3.multiply(rotMtx, mat3.rotation(angleInRad));
            rotMtx = mat3.multiply(rotMtx, mat3.translation(-orgImgWidth / 2, -orgImgHeight / 2));
            gl.uniformMatrix3fv(rotationMatrixLocation, false, rotMtx);

            const viewProjMtx = makeMatrix(originX, originY, scale);
            gl.uniformMatrix3fv(viewProjectionMatrixLocation, false, viewProjMtx);

            tiles.forEach(tile => {
                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                setRectangle(gl, tile.x, tile.y, tile.width, tile.height);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            });

            zoomLevelSpan.textContent = scale.toFixed(2);

            updatePanSlider();
            updateMinimap();

            // --- PLUGIN HOOK ---
            // Update the positions of HTML hotspot elements
            if (hotspotPlugin) {
                hotspotPlugin.update();
            }
        }


        // ---------------------------
        // --- Animation Functions ---
        // ---------------------------

        function cancelAllAnimations()
        {
            if (inertiaAnimationId) {
                cancelAnimationFrame(inertiaAnimationId);
                inertiaAnimationId = null;
            }

            if (elasticMoveAnimationId) {
                cancelAnimationFrame(elasticMoveAnimationId);
                elasticMoveAnimationId = null;
            }

            if (smoothZoomAnimationId) {
                cancelAnimationFrame(smoothZoomAnimationId);
                smoothZoomAnimationId = null;
            }

            isZooming = false;
        }


        /**
         * Smoothly animates the view to a new origin point with an ease-out effect.
         */
        function elasticMove(toX, toY)
        {
            cancelAllAnimations();

            const easeOutCubic = (t) => (--t) * t * t + 1;
            let duration = settings.elasticMoveDuration;
            let startTime = performance.now();
            const fromX = originX;
            const fromY = originY;

            function animate(time)
            {
                let t = Math.min((time - startTime) / duration, 1);
                originX = fromX + (toX - fromX) * easeOutCubic(t);
                originY = fromY + (toY - fromY) * easeOutCubic(t);
                render();
                if (t < 1) {
                    elasticMoveAnimationId = requestAnimationFrame(animate);
                } else {
                    elasticMoveAnimationId = null;
                }
            }

            elasticMoveAnimationId = requestAnimationFrame(animate);
        }


        /**
         * Gets the current image dimensions, accounting for rotation.
         */
        function getCurrentImageSize()
        {
            const i = rotation === 90 || rotation === 270;
            return {
                width: i ? orgImgHeight : orgImgWidth,
                height: i ? orgImgWidth : orgImgHeight
            };
        }


        /**
         * Checks if the view is outside the image boundaries and corrects it.
         */
        function checkEdges(elasticSnap = true)
        {
            const { width: imageWidth, height: imageHeight } = getCurrentImageSize();
            const viewWidth = canvas.width / scale;
            const viewHeight = canvas.height / scale;

            let targetX = originX;
            let targetY = originY;

            if (imageWidth < viewWidth) {
                targetX = (viewWidth - imageWidth) / 2;
            } else {
                const minOriginX = viewWidth - imageWidth;
                if (originX > 0) targetX = 0;
                if (originX < minOriginX) targetX = minOriginX;
            }

            if (imageHeight < viewHeight) {
                targetY = (viewHeight - imageHeight) / 2;
            } else {
                const minOriginY = viewHeight - imageHeight;
                if (originY > 0) targetY = 0;
                if (originY < minOriginY) targetY = minOriginY;
            }

            if (targetX !== originX || targetY !== originY) {
                if (elasticSnap) {
                    elasticMove(targetX, targetY);
                } else {
                    originX = targetX;
                    originY = targetY;
                    render();
                }
            }
        }

        /**
         * Linear interpolation
         */
        function lerp(s, e, a)
        {
            return (1 - a) * s + a * e;
        }


        /**
         * Smoothly interpolates the scale and origin to their target values.
         */
        function smoothZoomLoop()
        {
            isZooming = true;

            const smoothing = settings.zoomSmoothing;
            scale = lerp(scale, targetScale, smoothing);
            originX = lerp(originX, targetOriginX, smoothing);
            originY = lerp(originY, targetOriginY, smoothing);
            render();

            const scaleDiff = Math.abs(scale - targetScale);
            const originXDiff = Math.abs(originX - targetOriginX);
            const originYDiff = Math.abs(originY - targetOriginY);

            if (scaleDiff < 0.001 && originXDiff < 0.001 && originYDiff < 0.001) {
                scale = targetScale;
                originX = targetOriginX;
                originY = targetOriginY;
                isZooming = false;
                smoothZoomAnimationId = null;
                render();
                checkEdges(false);
            } else {
                smoothZoomAnimationId = requestAnimationFrame(smoothZoomLoop);
            }
        }


        /**
         * Simulates inertial movement after a pan, gradually slowing down.
         */
        function inertiaLoop()
        {
            const friction = settings.inertiaFriction;
            // const stopThreshold = setInitialView.inertiaStopThreshold;
			const stopThreshold = settings.inertiaStopThreshold;

            panVelocityX *= friction;
            panVelocityY *= friction;

            if (Math.abs(panVelocityX) < stopThreshold) {
                panVelocityX = 0;
            }

            if (Math.abs(panVelocityY) < stopThreshold) {
                panVelocityY = 0;
            }

            if (panVelocityX === 0 && panVelocityY === 0) {
                inertiaAnimationId = null;
                checkEdges();
                return;
            }

            const { width: imageWidth, height: imageHeight } = getCurrentImageSize();
            const viewWidth = canvas.width / scale;
            const viewHeight = canvas.height / scale;
            originX += panVelocityX / scale;
            originY += panVelocityY / scale;

            if (imageWidth > viewWidth) {
                const minOriginX = viewWidth - imageWidth;
                if (originX > 0 || originX < minOriginX) {
                    originX = Math.max(minOriginX, Math.min(0, originX));
                    panVelocityX = 0;
                }
            } else {
                originX = (viewWidth - imageWidth) / 2;
                panVelocityX = 0;
            }

            if (imageHeight > viewHeight) {
                const minOriginY = viewHeight - imageHeight;
                if (originY > 0 || originY < minOriginY) {
                    originY = Math.max(minOriginY, Math.min(0, originY));
                    panVelocityY = 0;
                }
            } else {
                originY = (viewHeight - imageHeight) / 2;
                panVelocityY = 0;
            }
            render();
            inertiaAnimationId = requestAnimationFrame(inertiaLoop);
        }


        /**
         * Checks if the image is panned out of its boundaries.
         */
        function isOutOfBounds()
        {
            const { width: imageWidth, height: imageHeight } = getCurrentImageSize();
            const viewWidth = canvas.width / scale;
            const viewHeight = canvas.height / scale;

            if (imageWidth > viewWidth) {
                const minOriginX = viewWidth - imageWidth;
                if (originX > 0 || originX < minOriginX) return true;
            }

            if (imageHeight > viewHeight) {
                const minOriginY = viewHeight - imageHeight;
                if (originY > 0 || originY < minOriginY) return true;
            }

            return false;
        }

        function debounce(func, timeout = 100)
        {
            let timer;

            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => {
                    func.apply(this, args);
                }, timeout);
            };
        }


        function initMinimap()
        {
            const minimap = document.getElementById('minimap-container');

            if (minimap) {
                minimap.style.setProperty('position', 'fixed', 'important');
                minimap.style.setProperty('top', '20px', 'important');
                minimap.style.setProperty('right', '20px', 'important');
                minimap.style.setProperty('bottom', null);
                minimap.style.setProperty('left', null);
            }
        }


        /**
         * Generates a small thumbnail for the minimap from the full-sized image.
         */
        function generateMinimapThumbnail(image)
        {
            const MAX_SIZE = settings.minimapMaxSize;
            const MIN_SIZE = settings.minimapMinSize;

            const thumbCanvas = document.createElement('canvas');
            const thumbCtx = thumbCanvas.getContext('2d');
            const aspect = image.width / image.height;

            if (aspect > 1) {
                thumbCanvas.width = MAX_SIZE;
                thumbCanvas.height = MAX_SIZE / aspect;
            } else {
                thumbCanvas.height = MAX_SIZE;
                thumbCanvas.width = MAX_SIZE * aspect;
            }

            thumbCtx.drawImage(image, 0, 0, thumbCanvas.width, thumbCanvas.height);
            const dataUrl = thumbCanvas.toDataURL('image/jpeg', 0.8);
            minimapImage.style.backgroundImage = `url(${dataUrl})`;

            let containerWidth, containerHeight;
            if (aspect > 1) {
                containerWidth = MAX_SIZE;
                containerHeight = containerWidth / aspect;
            } else {
                containerHeight = MAX_SIZE;
                containerWidth = containerHeight * aspect;
            }

            containerWidth = Math.max(containerWidth, MIN_SIZE);
            containerHeight = Math.max(containerHeight, MIN_SIZE);
            minimapContainer.style.width = containerWidth + 'px';
            minimapContainer.style.height = containerHeight + 'px';
            minimapContainer.style.display = 'block';
        }


        /**
         * Updates the position and size of the viewport indicator on the minimap.
         */
        function updateMinimap()
        {
            if (!orgImgWidth) {
                return;
            }

            const { width: imageWidth, height: imageHeight } = getCurrentImageSize();
            const viewWidth = canvas.width / scale;
            const viewHeight = canvas.height / scale;

            const imgRect = {
                x: 0,
                y: 0,
                width: imageWidth,
                height: imageHeight
            };

            const viewRect = {
                x: -originX,
                y: -originY,
                width: viewWidth,
                height: viewHeight
            };

            const intersectX = Math.max(imgRect.x, viewRect.x);
            const intersectY = Math.max(imgRect.y, viewRect.y);
            const intersectRight = Math.min(imgRect.x + imgRect.width, viewRect.x + viewRect.width);
            const intersectBottom = Math.min(imgRect.y + imgRect.height, viewRect.y + viewRect.height);
            const intersectWidth = intersectRight - intersectX;
            const intersectHeight = intersectBottom - intersectY;

            if (intersectWidth < 0 || intersectHeight < 0) {
                minimapViewport.style.width = '0px';
                minimapViewport.style.height = '0px';
                return;
            }

            const ratio = minimapContainer.clientWidth / imageWidth;
            minimapViewport.style.left = `${intersectX * ratio}px`;
            minimapViewport.style.top = `${intersectY * ratio}px`;
            minimapViewport.style.width = `${intersectWidth * ratio}px`;
            minimapViewport.style.height = `${intersectHeight * ratio}px`;
        }


        function jumpToOrigin(targetOriginX, targetOriginY)
        {
            cancelAllAnimations();

            const { width: imageWidth, height: imageHeight } = getCurrentImageSize();
            const viewWidth = canvas.width / scale;
            const viewHeight = canvas.height / scale;

            if (imageWidth > viewWidth) {
                originX = Math.max(viewWidth - imageWidth, Math.min(0, targetOriginX));
            } else {
                originX = (viewWidth - imageWidth) / 2;
            }

            if (imageHeight > viewHeight) {
                originY = Math.max(viewHeight - imageHeight, Math.min(0, targetOriginY));
            } else {
                originY = (viewHeight - imageHeight) / 2;
            }

            render();
        }


        function calculateTargetOriginForMinimapEvent(e)
        {
            const { width: imageWidth, height: imageHeight } = getCurrentImageSize();
            const rect = minimapContainer.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const targetWorldX = (clickX / rect.width) * imageWidth;
            const targetWorldY = (clickY / rect.height) * imageHeight;
            const viewWidth = canvas.width / scale;
            const viewHeight = canvas.height / scale;
            const targetOriginX = (viewWidth / 2) - targetWorldX;
            const targetOriginY = (viewHeight / 2) - targetWorldY;

            return {
                targetOriginX,
                targetOriginY
            };
        }


        function setInitialView()
        {
            if (!orgImgWidth) {
                return;
            }

            const { width: imageWidth, height: imageHeight } = getCurrentImageSize();
            const scaleToFitWidth = canvas.width / imageWidth;
            const scaleToFitHeight = canvas.height / imageHeight;
            const fitScale = Math.min(scaleToFitWidth, scaleToFitHeight);

            scale = targetScale = Math.min(1.0, fitScale);
            minScale = Math.min(scale, 0.1);

            checkEdges(false);
        }


        // ----------------------
        // --- Event Handlers ---
        // ----------------------

        function handleCanvasWheel(e) {
            e.preventDefault();
            cancelAllAnimations();

            const zoomFactor = 1.1;
            const scaleAmount = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            const newTargetScale = targetScale * scaleAmount;
            // Clamp the target scale
            targetScale = Math.max(minScale, Math.min(newTargetScale, 20));

            // Calculate the raw target origin based on mouse position
            const worldMouseX = (lastMouseX / scale) - originX;
            const worldMouseY = (lastMouseY / scale) - originY;
            const rawTargetOriginX = (lastMouseX / targetScale) - worldMouseX;
            const rawTargetOriginY = (lastMouseY / targetScale) - worldMouseY;

            // Apply edge-snapping logic directly to the TARGET values before animating
            const { width: imageWidth, height: imageHeight } = getCurrentImageSize();
            const viewWidthAtTarget = canvas.width / targetScale;
            const viewHeightAtTarget = canvas.height / targetScale;

            if (imageWidth < viewWidthAtTarget) {
                // If image is narrower than viewport, center it
                targetOriginX = (viewWidthAtTarget - imageWidth) / 2;
            } else {
                // Otherwise, clamp it within the horizontal bounds
                const minOriginX = viewWidthAtTarget - imageWidth;
                targetOriginX = Math.max(minOriginX, Math.min(0, rawTargetOriginX));
            }

            if (imageHeight < viewHeightAtTarget) {
                // If image is shorter than viewport, center it
                targetOriginY = (viewHeightAtTarget - imageHeight) / 2;
            } else {
                // Otherwise, clamp it within the vertical bounds
                const minOriginY = viewHeightAtTarget - imageHeight;
                targetOriginY = Math.max(minOriginY, Math.min(0, rawTargetOriginY));
            }

            if (!isZooming) {
                smoothZoomAnimationId = requestAnimationFrame(smoothZoomLoop);
            }
        }


        function handleCanvasDoubleClick(e)
        {
            e.preventDefault();
            cancelAllAnimations();

            let finalScale = (Math.abs(scale - 1.0) < 0.01) ? 0.25 : 1;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            targetScale = finalScale;

            const worldMouseX = (lastMouseX / scale) - originX;
            const worldMouseY = (lastMouseY / scale) - originY;
            const rawTargetOriginX = (lastMouseX / targetScale) - worldMouseX;
            const rawTargetOriginY = (lastMouseY / targetScale) - worldMouseY;
            const { width: imageWidth, height: imageHeight } = getCurrentImageSize();

            const viewWidthAtTarget = canvas.width / targetScale;
            if (imageWidth < viewWidthAtTarget) {
                targetOriginX = (viewWidthAtTarget - imageWidth) / 2;
            } else {
                const minOriginX = viewWidthAtTarget - imageWidth;
                targetOriginX = Math.max(minOriginX, Math.min(0, rawTargetOriginX));
            }

            const viewHeightAtTarget = canvas.height / targetScale;
            if (imageHeight < viewHeightAtTarget) {
                targetOriginY = (viewHeightAtTarget - imageHeight) / 2;
            } else {
                const minOriginY = viewHeightAtTarget - imageHeight;
                targetOriginY = Math.max(minOriginY, Math.min(0, rawTargetOriginY));
            }

            if (!isZooming) {
                smoothZoomAnimationId = requestAnimationFrame(smoothZoomLoop);
            }
        }


        function handleWindowKeyDown(e)
        {
            const { width: imageWidth, height: imageHeight } = getCurrentImageSize();
            const viewWidth = canvas.width / scale;
            const viewHeight = canvas.height / scale;
            let targetX = originX,
                targetY = originY,
                needsMove = false,
                needsRender = false;

            switch (e.key) {
                case 'Home':
                    if (imageWidth > viewWidth) {
                        targetX = 0;
                        needsMove = true;
                    }
                    break;

                case 'End':
                    if (imageWidth > viewWidth) {
                        targetX = viewWidth - imageWidth;
                        needsMove = true;
                    }
                    break;

                case 'PageUp':
                    if (imageHeight > viewHeight) {
                        targetY = 0;
                        needsMove = true;
                    }
                    break;

                case 'PageDown':
                    if (imageHeight > viewHeight) {
                        targetY = viewHeight - imageHeight;
                        needsMove = true;
                    }
                    break;

                case 'r':
                case 'R':
                    if (e.ctrlKey) break;
                    e.preventDefault();
                    rotation = (rotation + 90) % 360;
                    checkEdges(false);
                    needsRender = true;
                    break;

                default:
                    return;
            }

            if (needsMove) {
                e.preventDefault();
                elasticMove(targetX, targetY);
            } else if (needsRender) {
                render();
            }
        }


        function handleCanvasMouseMove(e)
        {
            if (!panning) {
                return;
            }

            const now = performance.now();
            const timeDelta = now - lastPanTime;
            if (timeDelta > 0) {
                panVelocityX = (e.clientX - lastMouseX);
                panVelocityY = (e.clientY - lastMouseY);
            }

            lastPanTime = now;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            originX = (e.clientX / scale) - startX;

            let newOriginY = (e.clientY / scale) - startY;
            const { height: imageHeight } = getCurrentImageSize();
            const viewHeight = canvas.height / scale;

            if (imageHeight < viewHeight) {
                newOriginY = (viewHeight - imageHeight) / 2;
            }
            originY = newOriginY;
            render();
        }


        function handleCanvasMouseDown(e)
        {
            cancelAllAnimations();

            panning = true;
            startX = (e.clientX / scale) - originX;
            startY = (e.clientY / scale) - originY;
            panVelocityX = 0;
            panVelocityY = 0;
            lastPanTime = performance.now();
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            window.addEventListener('mousemove', handleCanvasMouseMove);
            window.addEventListener('mouseup', handleCanvasMouseUp);
        };


        function handleCanvasMouseUp()
        {
            if (panning) {
                panning = false;
                window.removeEventListener('mousemove', handleCanvasMouseMove);
                window.removeEventListener('mouseup', handleCanvasMouseUp);
                if (isOutOfBounds()) {
                    checkEdges();
                } else if (panVelocityX !== 0 || panVelocityY !== 0) {
                    cancelAllAnimations();
                    inertiaAnimationId = requestAnimationFrame(inertiaLoop);
                }
            }
        }


        function handleDocumentMouseLeave()
        {
            if(panning) {
                handleCanvasMouseUp();
            }
        }


        function updatePanSlider()
        {
            const { width: imageWidth } = getCurrentImageSize();
            const viewWidth = canvas.width / scale;
            const isPannable = imageWidth > viewWidth;

            panSlider.disabled = !isPannable;

            if (isPannable) {
                const minOriginX = viewWidth - imageWidth;
                if (minOriginX >= 0) {
                    panSlider.value = 0;
                    return;
                }
                const percent = originX / minOriginX;
                panSlider.value = percent * 100;
            } else {
                panSlider.value = 0;
            }
        }


        function handleSliderInput()
        {
            const { width: imageWidth } = getCurrentImageSize();
            const viewWidth = canvas.width / scale;
            const minOriginX = viewWidth - imageWidth;

			// Lock the scale and Y-axis to their current values
			targetScale = scale;
			targetOriginY = originY; 

            targetOriginX = minOriginX * (panSlider.value / 100);

            if (!isZooming) {
                requestAnimationFrame(smoothZoomLoop);
            }
        }


        function handleCanvasMousePositionStatus(e)
        {
            const { width: iw, height: ih } = getCurrentImageSize();
            const x = Math.max(0, Math.min(iw, Math.floor((e.clientX / scale) - originX))),
                  y = Math.max(0, Math.min(ih, Math.floor((e.clientY / scale) - originY)));
            mouseCoordsSpan.textContent = `${x},${y}`;
            
            // --- PLUGIN HOOK ---
            // Let the plugin know where the mouse is
            if (hotspotPlugin) {
                hotspotPlugin.onMouseMove(e);
            }
        }


        function handleWindowResize()
        {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            setInitialView();
            render();
        }


        function handleMinimapMouseDown(e)
        {
            e.preventDefault();
            const { targetOriginX, targetOriginY } = calculateTargetOriginForMinimapEvent(e);

            jumpToOrigin(targetOriginX, targetOriginY);

            const onDrag = (moveEvent) => {
                const {
                    targetOriginX,
                    targetOriginY
                } = calculateTargetOriginForMinimapEvent(moveEvent);

                jumpToOrigin(targetOriginX, targetOriginY);
            };

            const onDragEnd = () => {
                window.removeEventListener('mousemove', onDrag);
                window.removeEventListener('mouseup', onDragEnd);
            };

            window.addEventListener('mousemove', onDrag);
            window.addEventListener('mouseup', onDragEnd);
        }


        // ---------------------------------------------------
        // --- Main, this is where we start executing code ---
        // ---------------------------------------------------

        // WebGL initialization
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const positionLocation = gl.getAttribLocation(program, "a_position");
        const texcoordLocation = gl.getAttribLocation(program, "a_texcoord");
        const viewProjectionMatrixLocation = gl.getUniformLocation(program, "u_viewProjectionMatrix");
        const rotationMatrixLocation = gl.getUniformLocation(program, "u_rotationMatrix");

        // Set up WebGL Buffers
        const positionBuffer = gl.createBuffer();
        const texcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);

        // Set up event listeners
        document.body.addEventListener('mouseleave', handleDocumentMouseLeave);

        window.addEventListener('keydown',   handleWindowKeyDown);
        window.addEventListener('resize',    debounce(handleWindowResize, 100));
		window.addEventListener('mousemove', handleCanvasMousePositionStatus);

        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('dblclick',  handleCanvasDoubleClick);
        canvas.addEventListener('wheel',     handleCanvasWheel, { passive: false });

        panSlider.addEventListener('input',  handleSliderInput);
        panSlider.addEventListener('mousedown', (e) => e.stopPropagation());

        minimapContainer.addEventListener('mousedown', handleMinimapMouseDown);

        initMinimap();

        // Really start stuff up, load image and initialize us
        // loadImageAndCreateTextureInfo('32k-wide-image.png', () => {
        // loadImageAndCreateTextureInfo('xanadu-reconstruction.png', () => {
        // loadImageAndCreateTextureInfo('BTCUSDT-james-wynn.png', () => {
        loadImageAndCreateTextureInfo(`./assets/BTCUSDT.png?cb=${Date.now()}`, async () => {
            setInitialView();
            render();

            imageSizePixelsSpan.textContent = `${orgImgWidth}x${orgImgHeight}`;
            imageSizeBytesSpan.textContent = formatBytes(orgImgBytes);
            updatePanSlider();
            
            if(true) {
                // --- PLUGIN INITIALIZATION ---

                // 1. Define the metadata for our hotspots
                const hotspotData = await (await fetch(`./assets/events-metadata.json?cb=${Date.now()}`)).json();

                // 2. Create the viewer "API" object for the plugin
                const viewerApi = {
                    getTransform: () => ({ scale, originX, originY }),
                    getCanvas: () => canvas,
                    requestRender: render
                };

                // 3. Instantiate the plugin
                hotspotPlugin = new HotspotPlugin(viewerApi, { hotspots: hotspotData });
                hotspotPlugin.update();
            }
        });

    });
</script>
</body>

</html>